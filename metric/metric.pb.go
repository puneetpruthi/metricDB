// Code generated by protoc-gen-go. DO NOT EDIT.
// source: metric.proto

/*
Package metric is a generated protocol buffer package.

It is generated from these files:
	metric.proto

It has these top-level messages:
	SetRequest
	GetRequest
	MetricData
	Status
*/
package metric

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SetRequest struct {
	Uid   string `protobuf:"bytes,1,opt,name=uid" json:"uid,omitempty"`
	Count int64  `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
}

func (m *SetRequest) Reset()                    { *m = SetRequest{} }
func (m *SetRequest) String() string            { return proto.CompactTextString(m) }
func (*SetRequest) ProtoMessage()               {}
func (*SetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SetRequest) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *SetRequest) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type GetRequest struct {
	Uid      string                     `protobuf:"bytes,1,opt,name=uid" json:"uid,omitempty"`
	FromTime *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=fromTime" json:"fromTime,omitempty"`
	ToTime   *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=toTime" json:"toTime,omitempty"`
	Interval int64                      `protobuf:"varint,4,opt,name=interval" json:"interval,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GetRequest) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *GetRequest) GetFromTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.FromTime
	}
	return nil
}

func (m *GetRequest) GetToTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.ToTime
	}
	return nil
}

func (m *GetRequest) GetInterval() int64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

type MetricData struct {
	Uid    string  `protobuf:"bytes,1,opt,name=uid" json:"uid,omitempty"`
	Counts []int64 `protobuf:"varint,2,rep,packed,name=counts" json:"counts,omitempty"`
}

func (m *MetricData) Reset()                    { *m = MetricData{} }
func (m *MetricData) String() string            { return proto.CompactTextString(m) }
func (*MetricData) ProtoMessage()               {}
func (*MetricData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MetricData) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *MetricData) GetCounts() []int64 {
	if m != nil {
		return m.Counts
	}
	return nil
}

type Status struct {
	RetStatus int64 `protobuf:"varint,1,opt,name=retStatus" json:"retStatus,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Status) GetRetStatus() int64 {
	if m != nil {
		return m.RetStatus
	}
	return 0
}

func init() {
	proto.RegisterType((*SetRequest)(nil), "metric.SetRequest")
	proto.RegisterType((*GetRequest)(nil), "metric.GetRequest")
	proto.RegisterType((*MetricData)(nil), "metric.MetricData")
	proto.RegisterType((*Status)(nil), "metric.Status")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MetricService service

type MetricServiceClient interface {
	// Client sends a stream of metrics <UID,count> to save to db
	SetMetric(ctx context.Context, opts ...grpc.CallOption) (MetricService_SetMetricClient, error)
	// Client sends a <UID> and N point request to return metrics for N time intervals
	GetMetric(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*MetricData, error)
}

type metricServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetricServiceClient(cc *grpc.ClientConn) MetricServiceClient {
	return &metricServiceClient{cc}
}

func (c *metricServiceClient) SetMetric(ctx context.Context, opts ...grpc.CallOption) (MetricService_SetMetricClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MetricService_serviceDesc.Streams[0], c.cc, "/metric.MetricService/SetMetric", opts...)
	if err != nil {
		return nil, err
	}
	x := &metricServiceSetMetricClient{stream}
	return x, nil
}

type MetricService_SetMetricClient interface {
	Send(*SetRequest) error
	CloseAndRecv() (*Status, error)
	grpc.ClientStream
}

type metricServiceSetMetricClient struct {
	grpc.ClientStream
}

func (x *metricServiceSetMetricClient) Send(m *SetRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *metricServiceSetMetricClient) CloseAndRecv() (*Status, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Status)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metricServiceClient) GetMetric(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*MetricData, error) {
	out := new(MetricData)
	err := grpc.Invoke(ctx, "/metric.MetricService/GetMetric", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MetricService service

type MetricServiceServer interface {
	// Client sends a stream of metrics <UID,count> to save to db
	SetMetric(MetricService_SetMetricServer) error
	// Client sends a <UID> and N point request to return metrics for N time intervals
	GetMetric(context.Context, *GetRequest) (*MetricData, error)
}

func RegisterMetricServiceServer(s *grpc.Server, srv MetricServiceServer) {
	s.RegisterService(&_MetricService_serviceDesc, srv)
}

func _MetricService_SetMetric_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MetricServiceServer).SetMetric(&metricServiceSetMetricServer{stream})
}

type MetricService_SetMetricServer interface {
	SendAndClose(*Status) error
	Recv() (*SetRequest, error)
	grpc.ServerStream
}

type metricServiceSetMetricServer struct {
	grpc.ServerStream
}

func (x *metricServiceSetMetricServer) SendAndClose(m *Status) error {
	return x.ServerStream.SendMsg(m)
}

func (x *metricServiceSetMetricServer) Recv() (*SetRequest, error) {
	m := new(SetRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MetricService_GetMetric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricServiceServer).GetMetric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metric.MetricService/GetMetric",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricServiceServer).GetMetric(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MetricService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "metric.MetricService",
	HandlerType: (*MetricServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMetric",
			Handler:    _MetricService_GetMetric_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SetMetric",
			Handler:       _MetricService_SetMetric_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "metric.proto",
}

func init() { proto.RegisterFile("metric.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 285 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x91, 0xcf, 0x4a, 0xc3, 0x40,
	0x10, 0xc6, 0x9b, 0xae, 0x86, 0x66, 0xfc, 0x83, 0x0c, 0x22, 0x21, 0x08, 0x96, 0x3d, 0x48, 0x4e,
	0x29, 0xa4, 0xda, 0x27, 0x10, 0x7a, 0xf2, 0xb2, 0xe9, 0x0b, 0xa4, 0x71, 0x5a, 0x16, 0x9a, 0x6e,
	0xdd, 0x4c, 0x7a, 0xf1, 0x7d, 0x7c, 0x4e, 0x71, 0x37, 0x4d, 0x0e, 0x8a, 0xde, 0xf6, 0xfb, 0x98,
	0xdf, 0xf0, 0xcd, 0xb7, 0x70, 0x59, 0x13, 0x5b, 0x5d, 0x65, 0x07, 0x6b, 0xd8, 0x60, 0xe8, 0x55,
	0xf2, 0xb0, 0x35, 0x66, 0xbb, 0xa3, 0x99, 0x73, 0xd7, 0xed, 0x66, 0xc6, 0xba, 0xa6, 0x86, 0xcb,
	0xfa, 0xe0, 0x07, 0xe5, 0x13, 0x40, 0x41, 0xac, 0xe8, 0xbd, 0xa5, 0x86, 0xf1, 0x06, 0x44, 0xab,
	0xdf, 0xe2, 0x60, 0x1a, 0xa4, 0x91, 0xfa, 0x7e, 0xe2, 0x2d, 0x9c, 0x57, 0xa6, 0xdd, 0x73, 0x3c,
	0x9e, 0x06, 0xa9, 0x50, 0x5e, 0xc8, 0xcf, 0x00, 0x60, 0xf9, 0x17, 0xb6, 0x80, 0xc9, 0xc6, 0x9a,
	0x7a, 0xa5, 0x6b, 0x72, 0xe4, 0x45, 0x9e, 0x64, 0x3e, 0x4a, 0x76, 0x8a, 0x92, 0xad, 0x4e, 0x51,
	0x54, 0x3f, 0x8b, 0x39, 0x84, 0x6c, 0x1c, 0x25, 0xfe, 0xa5, 0xba, 0x49, 0x4c, 0x60, 0xa2, 0xf7,
	0x4c, 0xf6, 0x58, 0xee, 0xe2, 0x33, 0x97, 0xb2, 0xd7, 0x72, 0x01, 0xf0, 0xea, 0x9a, 0x78, 0x29,
	0xb9, 0xfc, 0x25, 0xe7, 0x1d, 0x84, 0xee, 0xa2, 0x26, 0x1e, 0x4f, 0x45, 0x2a, 0x54, 0xa7, 0xe4,
	0x23, 0x84, 0x05, 0x97, 0xdc, 0x36, 0x78, 0x0f, 0x91, 0x25, 0xf6, 0xc2, 0x91, 0x42, 0x0d, 0x46,
	0xfe, 0x01, 0x57, 0x7e, 0x7f, 0x41, 0xf6, 0xa8, 0x2b, 0xc2, 0x39, 0x44, 0x05, 0xb1, 0xf7, 0x10,
	0xb3, 0xee, 0x53, 0x86, 0x8a, 0x93, 0xeb, 0xde, 0x73, 0x1b, 0xe4, 0x28, 0x0d, 0xf0, 0x19, 0xa2,
	0xe5, 0x4f, 0x68, 0x28, 0x38, 0xe9, 0xbd, 0xe1, 0x18, 0x39, 0x5a, 0x87, 0xae, 0x94, 0xf9, 0x57,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x93, 0x5f, 0x84, 0x00, 0xfb, 0x01, 0x00, 0x00,
}
